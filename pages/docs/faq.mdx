# FAQ

Frequently asked questions about ReactBlueprint patterns and conventions.

import { Callout } from 'nextra/components'

## General

### Why these specific technologies?

Our tech stack (React, TypeScript, Zustand, TanStack Query) is chosen for:

- **Minimal boilerplate** — Less code to write and maintain
- **Type safety** — Catch errors before runtime
- **Performance** — Optimized for production
- **Developer experience** — Great tooling and debugging
- **Community** — Active maintenance and support

### Is this guide opinionated?

Yes, intentionally. We believe consistency and conventions reduce cognitive load and make codebases more maintainable. These patterns are battle-tested in production.

### Can I use different libraries?

Absolutely. The principles apply regardless of specific libraries. For example:
- Redux Toolkit instead of Zustand
- SWR instead of TanStack Query
- styled-components instead of Tailwind

---

## State Management

### When should I use Zustand vs Context?

<Callout type="info">
  **Zustand** for frequently changing global state (auth, UI state).
  **Context** for rarely changing values (theme, locale, feature flags).
</Callout>

Context causes all consumers to re-render when the value changes. Zustand only re-renders components that select the changed value.

### Should I put API data in Zustand?

No. Server data should be managed by TanStack Query (or similar). This gives you:
- Automatic caching
- Background refetching
- Loading/error states
- Deduplication

Zustand is for **client-only** state like UI preferences, form drafts, or auth tokens.

### How do I share state between features?

1. **Global stores** (`/stores`) — For truly global state like auth
2. **Lifting state up** — Move to common parent when few levels
3. **URL state** — For shareable/bookmarkable state
4. **Feature composition** — Features can import from other features

---

## Components

### How do I decide between one big component vs many small ones?

Signs you should split:
- Component file exceeds 150 lines
- JSX exceeds 50 lines
- Multiple unrelated responsibilities
- Hard to name (does too many things)
- Difficult to test

### When should I use `memo()`?

Use `memo()` when:
- Component renders often with same props
- Component is expensive to render
- Parent re-renders frequently

Don't use when:
- Props change every render anyway
- Component is simple/fast
- Premature optimization

### Should I use default exports or named exports?

We recommend **named exports** for components:

```typescript
// ✅ Named export
export const UserCard = () => {};

// ❌ Default export
export default function UserCard() {}
```

Named exports:
- Enable better refactoring
- Prevent typos
- Work better with IDE autocomplete

---

## TypeScript

### Interface vs Type — which should I use?

| Use Case | Recommendation |
|----------|----------------|
| Object shapes | `interface` |
| Union types | `type` |
| Function types | `type` |
| Props | `interface` |
| Extending | `interface` |

### How do I handle `any`?

Never use `any`. Instead:
- `unknown` + type guards for external data
- Proper types for API responses (use Zod)
- `as const` for literal types
- Generics for reusable functions

### Should I use enums?

Prefer **const objects** or **union types**:

```typescript
// ❌ Avoid enums
enum Status {
  ACTIVE = 'ACTIVE',
  INACTIVE = 'INACTIVE',
}

// ✅ Prefer union types
type Status = 'ACTIVE' | 'INACTIVE';

// ✅ Or const objects for runtime values
const STATUS = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
} as const;

type Status = typeof STATUS[keyof typeof STATUS];
```

---

## Testing

### What should I test?

**Priority order:**
1. User interactions (clicks, form submissions)
2. Conditional rendering
3. Error and loading states
4. Edge cases

**Skip testing:**
- Third-party library internals
- Simple presentational components
- Implementation details

### Should I test implementation or behavior?

**Always test behavior.** Tests should not break when you refactor.

```typescript
// ❌ Testing implementation
expect(component.state.isOpen).toBe(true);

// ✅ Testing behavior
expect(screen.getByRole('dialog')).toBeVisible();
```

### How do I mock API calls?

Use **MSW (Mock Service Worker)**:

```typescript
import { http, HttpResponse } from 'msw';
import { setupServer } from 'msw/node';

const server = setupServer(
  http.get('/api/users', () => {
    return HttpResponse.json([{ id: '1', name: 'John' }]);
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

---

## Performance

### When should I optimize?

1. **Measure first** — Use React DevTools Profiler
2. **Identify bottlenecks** — Focus on actual slow spots
3. **Apply targeted fixes** — Don't optimize everything

### How big should my bundle be?

| Metric | Target |
|--------|--------|
| Main bundle | < 200KB gzipped |
| Total initial | < 500KB gzipped |
| Individual chunks | < 100KB |

### Should I lazy load everything?

Lazy load:
- Routes/pages
- Large libraries (charts, editors)
- Below-the-fold content
- Rarely used features

Don't lazy load:
- Critical UI components
- Small utilities
- Anything needed immediately

---

## Project Structure

### Can I have a flat structure?

For small projects (< 10 components), flat is fine:

```
src/
├── components/
├── hooks/
├── services/
└── utils/
```

For larger projects, feature-based structure scales better.

### How deep should nesting go?

Maximum **4 levels**. If you need more, reconsider your structure.

```
src/features/users/components/UserCard/UserCard.tsx  ✅ (4 levels)
src/features/users/components/cards/user/UserCard.tsx  ❌ (5 levels)
```
